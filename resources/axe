local function log(level, msg)
    if level == 0 then
        term.setTextColor(colors.red)
        print("[CRIT] "..msg)
    elseif level == 1 then
        term.setTextColor(colors.yellow)
        print("[WARN] "..msg)
    elseif level == 2 then
        term.setTextColor(colors.white)
        print("[INFO] "..msg)
    end
    term.setTextColor(colors.white)
end

local function turn(direction, orientation)
    local finalorientation = 0
    local delta = 0
    if direction == "f" then
        delta = math.fmod(5 - orientation, 4) - 1
        finalorientation = 0
    elseif direction == "r" then
        delta = 1 - math.fmod(orientation, 4)
        finalorientation = 1
    elseif direction == "b" then
        delta = 2 - math.fmod(orientation, 4)
        finalorientation = 2
    elseif direction == "l" then
        delta = math.fmod(5 - orientation, 4) - 2
        finalorientation = 3
    end
    while delta ~= 0 do
        if delta < 0 then
            turtle.turnLeft()
            delta = delta + 1
        else
            turtle.turnRight()
            delta = delta - 1
        end
    end
    return finalorientation
end

local function isPrecious(name)
    return string.find(name,"log") or string.find(name,"leaves") or string.find(name, "sapling")
end

local function countAll(name)
    sum = 0
    for i=1,16 do
        turtle.select(i)
        data = turtle.getItemDetail()
        if data ~= nil and string.find(data.name, name) then
            sum += turtle.getItemCount()
        end
    end
end

mined = 0

local function recursiveMine()
    -- Start slice inspection. Assumes we are facing forward.
    local orientation = 0
    
    -- Check forward
    success,data = turtle.inspect()
    if success and (isPrecious(data.name)) then
        turtle.dig()
        mined = mined + 1
        turtle.forward()
        
        recursiveMine()
        orientation = turn("b",orientation)
        turtle.forward()
        
    end

     -- Check left
     orientation = turn("l",orientation)
     success,data = turtle.inspect()
     if success and (isPrecious(data.name)) then
         turtle.dig()
         mined = mined + 1
         turtle.forward()
         
         recursiveMine()
         orientation = turn("r",orientation)
         turtle.forward()
         
     end

     -- Check right
    orientation = turn("r",orientation)
    success,data = turtle.inspect()
    if success and (isPrecious(data.name)) then
        turtle.dig()
        mined = mined + 1
        turtle.forward()
        
        recursiveMine()
        orientation = turn("l",orientation)
        turtle.forward()
        
    end

    -- Check up
    local success,data = turtle.inspectUp()
    if success and (isPrecious(data.name)) then
        turtle.digUp()
        mined = mined + 1
        turtle.up()
        
        recursiveMine()
        turtle.down()
        
    end

    -- Check backwards
    orientation = turn("b",orientation)
    success,data = turtle.inspect()
    if success and (isPrecious(data.name)) then
        turtle.dig()
        mined = mined + 1
        turtle.forward()
        
        recursiveMine()
        orientation = turn("f",orientation)
        turtle.forward()
        
    end

    -- Check down
    success,data = turtle.inspectDown()
    if success and (isPrecious(data.name)) then
        turtle.digDown()
        mined = mined + 1
        turtle.down()
        
        recursiveMine()
        turtle.up()
        
    end

    -- Restore orientation
    orientation = turn("f",orientation)
    -- End slice inspection
end

local function forceForward()
    while(not turtle.forward()) do  
        turtle.dig()
    end
end

local function forceUp()
    while(not turtle.up()) do  
        turtle.digUp()
    end
end

local function forceDown()
    while(not turtle.down()) do  
        turtle.digDown()
    end
end

log(2, "axe version: 4")
if table.getn(arg) == 0 then
    log(2, "Usage: axe <length>, length specifies how long the line of trees is.")
    return
end

length = tonumber(arg[1])

local success,data = turtle.inspect()

local orientation = 0

while true do
    log(2, "Waiting for trees to grow up.")
    while not success or not string.find(data.name, "log") do
        success,data = turtle.inspect()
        os.sleep(5)
    end
    fuel = turtle.getFuelLevel()
    recursiveMine()
    log(2, "Mined "..mined.." blocks and consumed "..(fuel - turtle.getFuelLevel()).." fuel.")
    log(2, "Depositing items...")
    -- Drop everything but saplings
    for i=1,16 do
        item = turtle.getItemDetail()
        if not string.find(item.name, "sapling") then
            turtle.select(i)
            turtle.dropDown()
        else
            for j=1,i do
                turtle.select(j)
                if turtle.getItemCount() < 64 then 
                    turtle.select(i)
                    turtle.transferTo(j)
                    turtle.select(i)
                    if turtle.getItemCount() <= 0 then
                        break
                    end
                end
            end
            
        end
    end
    -- (TODO) Count up all saplings to support lengths > 64
    totalSaplings = countAll("sapling")
    if totalSaplings < length then
        log(2, "Getting saplings from surplus chest.")
        orientation = turn("l", orientation)
        turtle.forward()
        while(countAll("sapling") < length) do end
        orientation = turn("r", orientation)
        turtle.forward()
    end

    if totalSaplings > length then
        log(2, "Depositing excess saplings.")
        turtle.up()
        turtle.up()
        orientation = turn("l",orientation)
        turtle.select(1)
        amount = turtle.getItemCount()
        turtle.drop(amount - length)
        turtle.down()
        turtle.down()
    end

    turtle.up()
    for i=1,length do
        forceForward()
    end
    orientation = turn("b",orientation)
    for i=1,length do
        turtle.placeDown()
        forceForward()
    end
    turtle.down()
    orientation = turn("f",orientation)
end
